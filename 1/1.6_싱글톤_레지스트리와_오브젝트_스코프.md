# 1.6 싱글톤 레지스트리와 오브젝트 스코프

애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와 중요한 차이점이 있다. 먼저 DaoFactory의 userDao() 메소드를 두 번 호출해서 리턴되는 UserDao 객체는 동일할까?


> **오브젝트위 동일성과 동등성**
>
> 간단히 말해서 동일성은 `==` 이고, 동등성은 `.equals()` 로 설명할 수 있다. 두 개의 객체가 동일하다면 실제로는 하나의 객체만 존재하는 것이고 두 개의 객체의 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 객체가 동등하다면 각기 다른 객체가 메모리상에 존재하는 것인데, 객체의 정보를 보고 동등하다고 판단하는 것이다.
> 물론 동일한 객체는 동등하다고 할 수 있지만 반대로 동등한 객체는 동일하다고 볼 수 없다.
>


```java
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(connctionMaker());
    }
}
```

위 메소드를 보면 `new` 키워드를 통해 새로운 객체를 생성한다. 따라서 매번 다른 객체가 생성될 것이라고 예상할 수 있다.

```java
@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        return new UserDao(connctionMaker());
    }
}
```

이번엔 DAO를 애플리케이션 컨텍스트에 설정 정보를 등록하고 getBean()메소드를 이용하여 가져온다.

```java
ApplicationContext context = new AnnotationconfigApplicationContext(DaoFactory.class);
UserDao dao1 = context.getBean("userDao", UserDao.class);
UserDao dao2 = context.getBean("userDao", UserDao.class);

System.out.println(dao1);
System.out.println(dao2);
```

이 코드의 실행 결과는 아래와 같다.

```
spring.dao.UserDao@ee22f7
spring.dao.UserDao@ee22f7
```

두 객체의 출력 값이 같으므로 getBean() 두 번 호출해서 가져온 오브젝트가 동일하다는 것을 알 수 있다. (dao1 == dao2)

스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 객체를 돌려준다는 것이다.

## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 객체를 모두 싱글톤으로 만든다.
(싱글톤 패턴과 유사하지만 구현 방법이 다르다.)

### 서버 애플리케이션과 싱글톤

왜 스프링은 싱글톤으로 빈을 만드는 걸까? 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.

스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 초당 수십에서 수백 번씩 요청을 받아 처리할 수 있는 높은 성능을 요구했다. 매번 많은 새로운 객체를 생성하고 해제하기엔 자바와 GC 성능이 좋아져도 한계가 있다.
따라서 이러한 환경에서는 싱글톤이 적절하였다. 하지만 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 문제점이 있다.

> **싱글톤 패턴**
>
>
> 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수를 하나로 강제하는 패턴이다. 이렇게 하나만 만들어진 클래스의 객체는 애플리케이션 내에서 전역적으로 접근이 가능하다.
>

### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법은 이렇다.

- 클래스 밖에서 객체를 생성하지 못하도록 private로 만든다.
- 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 getInstance()를 만들고 최초로 호출하는 시점에 한번만 생성하고 이후에는 같은 객체를 제공한다.

```java
public class UserDao {
    private static UserDao INSTANCE;
    ...
    public static synchronized UserDao getInstance() {
        if (INSTANCE == null) INSTANCE = new UserDao();
        return INSTANCE;
    }
}
```

싱글톤은 다음과 같은 문제점을 가진다.

- **private 생성자를 가지고 있기 때문에 상속할 수 없다.**

  객체지향의 장점인 상속을 활용할 수 없고 다형성을 적용할 수 없다.

- **싱글톤은 테스트하기가 힘들다.**

  테스트하기가 어렵거나 불가능하다. 싱글톤은 만들어지는 방식이 제한적이기 때문에 Mock 객체 등으로 대체하기가 힘들다.

- **서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.**

  서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다. 여러 개의 JVM에 분산돼서 설치가 되는 경우에도 독립적인 오브젝트가 생성되기 때문에 가치가 떨어진다.

- **싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.**

  싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 스태틱 메소드를 이용해 언제든 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있고 전역상태가 되기 쉽다.


### 싱글톤 레지스트리

기본적으로 싱글톤 패턴의 구현 방식은 여러 가지 단점이 존재하기 때문에 스프링은 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.

이것이 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리의 장점은 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 것이다.

스프링은 싱글톤 레지스트리 덕분에 public 생성자를 가질 수 있기 때문에 테스트 환경에서 자유롭고 Mock 객체로 대체하는 것도 가능하다.

## 1.6.3 스프링 빈의 스코프

스프링이 관리하는 오브젝트, 즉 빈이 생성되고 존재하고 적용되는 범위에 대해 알아보자. 스프링에서는 이것을 빈 스코프라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.

경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토타입 스코프가 있다. 프로토타입은 컨테이너에 빈을 요청할 때마다 매번 새로운 객체를 만든다.
외에도 리퀘스트 스코프, 세션 스코프 등 다양한 스코프가 존재한다.