[1.1 초난감 DAO](#11-초난감-dao) <br>
[1.2 DAO의 분리](#12-dao의-분리) <br>
[1.3 DAO의 확장](#13-dao의-확장) <br>
[1.4 제어의_역전_IoC](#제어의-역전-ioc) <br>


스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 객체지향 프로그래밍이 가능한 언어라는 점이다.

스프링을 이해하려면 먼저 오브젝트에 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고 사용되고 소멸하기까지의 전 과정을 진지하게 생각해볼 필요가 있다.

스프링은 객체지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지 않는다. 하지만 오브젝트를 어떻게 효과적으로 설계하고 구현하고 사용하고 이를 개선해 나갈 것인가에 대한 명쾌한 기준을 마련해준다.

1장에서는 스프링이 어떤 것이고 무엇을 제공하는지보다는 스프링이 관심을 갖는 대상인 **오브젝트의 설계와 구현, 동작원리**에 더 집중한다.

## 1.1 초난감 DAO

사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 하나 만들어보자.

> 💡 DAO
> 
> DAO는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트이다.


### 1.1.1 User

```java
@Getter @Setter
public class User {
		String id;
		String name;
		String password;
}
```

User 오브젝트에 담긴 정보가 실제로 보관될 DB의 테이블 하나를 만들어보자.

```sql
create table users (
		id varchar(10) primary key,
		name varchar(20) not null,
		password varchar(10) not null
)
```


>💡 자바빈
>
>자바빈(JavaBean)은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. 비주얼 툴이 인기가 없어지면서 현재는 두 가지 관례를 따라 만들어진 오브젝트>를 가리킨다. 간단히 빈이라고 부르기도 한다.
>
> - 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다. 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
> - 프로퍼티: 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 setter와 getter를 가지고 있어야한다.



### 1.1.2 UserDao

사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자.

JDBC를 이용하는 일반적으로 순서는 다음과 같다.

1. DB연결을 위한 Connection을 가져온다.
2. SQL을 담은 Statement를 만든다.
3. 만들어진 Statement를 실행한다.
4. 조회의 경우 SQL 쿼리 실행 결과를 ResultSet을 받아서 정보를 저장할 오브젝트에 옮겨준다.
5. 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스를 닫아준다.
6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던진다.

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
            Class.forName("com.mysql.jdbc.Driver");
            Connection c = DriverManager.getConnection("jdbc:mysql://...");
            
            PreparedStatement ps = c.prepareStatement("insert into users ...");
            
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());

            ps.executeUpdate();

            ps.close();
            c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
            Class.forName("com.mysql.jdbc.Driver");
            Connection c = DriverManager.getConnection("jdbc:mysql://...");
            
            PreparedStatement ps = c.prepareStatement("select * from users ...");
            ps.setString(1, id);
            
            ResultSet rs = ps.executeQuery();
            rs.next();
            
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));

            rs.close();
            ps.close();
            c.close();
            
            return user;
    }
}
```

이 클래스가 제대로 동작하는지 어떻게 확인할 수 있을까?
일단 생각해볼 수 있는 방법은 DAO의 기능을 사용하는 애플리케이션을 만들어 서버에 배치하고 웹 브라우저를 통해 DAO 기능 사용해보는 것이다.

하지만 간단한 UserDao 코드를 테스트하기 위해 배보다 배꼽이 더 큰 상황이 나왔다.

따라서 main()에 작성하여 코드를 간단하게 테스트할 수 있다.

지금 만든 DAO는 많은 문제가 있다. 이 DAO를 객체지향 기술의 원리에 충실한 멋진 스프링 스타일의 코드로 개선해보는 작업을 할 것이다.

- 이 코드의 문제점은 뭘까?
- 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
- 이렇게 개선하였을 때 장점은 뭘까?
- 이 장점들이 이후에 주는 유익은 뭘까?
- 객체지향 설계와 무슨 관련이 있을까?
- 스프링을 사용하는 개발에서 무슨 차이가 있을까?

이러한 고민과 문제를 해결해나가는 과정이 스프링을 공부하는 것이다.

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

객체지향의 세계에서는 모든 것이 변한다. 개발에 끝이란 것은 없다. 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 변한다. 또한 기술도 시간에 따라 바뀐다.

그래서 개발자가 염두해 두어야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다. 미래에 닥칠지도 모르는 거대한 작업에 대한 부담과 변경에 따른 엄청난 스트레스, 그로 인해 발생하는 고객과 개발팀 내에서 갈등을 최소화할 수 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. 가장 좋은 대책은 변화의 폭을 최소한으로 줄이는 것이다. 이를 설계하는 것이 분리와 확장을 고려하는 것이다.

먼저 분리에 대해서 생각해보자.
”DB를 오라클에서 MySQL로 바꾸 싶다”, “DB의 암호를 바꾸고 싶다” 등의 요청사항이 들어오게 되었을 때, 수천개의 DAO를 변경하게 될 수도 있다.

**변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 한 가지 관심이 한 굴데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고 다른 것은 떨어져 있게 하는 것이다.**

### 1.2.2 커넥션 만들기의 추출

UserDao의 구현된 메소드를 다시 보면 `add()` 메소드 하나에서 적어도 세 가지 관심사항을 발견할 수 있다.

```java
public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://...");
    
    PreparedStatement ps = c.prepareStatement("insert into users ...");
    
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());
    
    ps.executeUpdate();
    
    ps.close();
    c.close();
}

```

**UserDao의 관심사항**

1. DB 연결 커넥션(DB 종류, 드라이버 종류, 로그인 정보 등)
2. Statement 생성하고 실행
3. 작업이 끝난 후 리소스 해제

+추가적으로 예외 처리가 전혀 없다.

가장 문제가 되는 첫 번째, DB 연결하는 코드이다. `add()` 이외에도 `get()` 메소드에도 중복적으로 들어가 있다.

**중복 코드의 메서드 추출**

중복된 DB 연결 코드를 getConnection()이라는 독립적인 메소드로 만들어준다.

```java
private Connection getConnection() {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://...");
    return c;
}
```

지금은 메소드가 두 개이지만 나중에 100개쯤 된다고 생각해보면 변경이 일어났을 경우, 전부가 아닌 `getConnection()` 만 변경하면 된다.

### 1.2.3 DB 커넥션 만들기의 독립

만약 N사와 D사, 두 고객사를 상대할 때 각각 다른 두 DB를 사용하길 원한다는 상황이다.

이런 경우 아예 UserDao 코드를 고객에게 제공해주고 변경이 필요하면 getConnection() 메소드를 수정해서 사용하라고 할 수 있다.

이러한 방식은 코드를 공개해야 하고 고객입장에서 좋은 방식은 아닐 것이다.

**상속을 통한 확장**

UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들어 놓으면 된다.

UserDao 클래스를 상속해서 각각 NUserDao, DUserDao라는 서브클래스로 만들면 된다. 이렇게 하면 UserDao를 확장해서 사용할 수 있다.

![image](https://github.com/Eui9179/spring3-study/assets/83222282/78f6bf8a-dd5a-4d16-accb-70c3007ec5c0)

```java
public abstract class UserDao {
    public void add(User user) { 
            Connection c = getConnection();
            ...
    }
    public User get(String id) {
            Connection c = getConnection();
            ...
    }
    
    public abstract Connection getConnection();
}
```

```java
public class NUserDao extends UserDao {
    @Override public Connection getConnection() { ... }
}
```

```java
public class DUserDao extends UserDao {
    @Override public Connection getConnection() { ... }
}
```

이제는 UserDao 코드는 한 줄도 수정할 필요 없이 DB 연결 기능을 새롭게 정의한 클래스를 만들 수 있다.
이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.

![image](https://github.com/Eui9179/spring3-study/assets/83222282/884d4d00-a8fd-4229-bf58-eb94dd6969d3)

위 이미지는 Connection을 클래스에 따라 생성해주는 **팩토리 패턴**을 사용한다.

하지만 이 방법은 상속을 사용했다는 것이 단점이다. 상속 자체는 간단해 보이고 편리하지만 한계점이 있다.

만약 이미 UserDao가 다른 목적으로 상속을 사용하고 있다면 어떻게 할 것인가?

상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다. 상속을 통해 관심이 다른 기능을 분리하고 필요에 따라 다양한 변신이 가능하도록 확장성도 줬지만 여전히 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한다. 슈퍼클래스 내부의 변경이 있을 때 모든 서브 클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

## 1.3 DAO의 확장

### 1.3.1 클래스 분리

이번에는 상속관계가 아닌 독립적인 클래스로 만들어보자.
방법은 DB 커넥션 관련된 부분을 서브 클래스가 아니라 별도의 클래스에 담는다. 이렇게 만든 클래스를 UserDao가 이용하면 된다.

![image](https://github.com/Eui9179/spring3-study/assets/83222282/2f30ef4e-10c8-4807-a681-47695337204c)


그림처럼 SimpleConnectionMaker를 UserDao에서 new 키워드로 객체를 생성해서 사용하면 된다.

```java
public class SimpleConnectionMaker() {

    public Connection makeNewConnection() {
            Class.forName("com.mysql.jdbc.Driver");
            Connection c = DriverManager.getConnection("jdbc:mysql://...");
            return c;
    }
}
```

```java
public Class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
            simpleConnectionMaker = new SimpleConnectionMaker();
    }
    // add(), get() ...
}
```

기존 코드에 많은 수정을 했지만 기능에 변화를 준 것은 없다.

성격이 다른 코드를 확실히 분리하기는 했는데, N사와 D사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용했던 게 다시 불가능해졌다.

UserDao의 코드가 특정 클래스에 종속되어 있기 때문이다.

다른 DB 커넥션을 생성하기 위해서는
`simpleConnectionMaker = new SimpleConnectionMaker();`
부분을 수정해야 한다.

클래스를 분리한 경우에도 DB 커넥션을 제공하는 클래스가 어떤 것인지 UserDao가 구체적으로 알고 있어야 한다. 만약 N 사에서 다른 클래스를 구현하면 어쩔 수 없이 UserDao 자체를 다시 수정해야 한다.

이런 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. 따라서 UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버린다.

### 1.3.2 인터페이스 도입

클래스를 분리하면서 이런 문제를 해결하는 **가장 좋은 방법은 두 개의 클래스 중간에 추상적인 느슨한 연결고리를 만들어 주는 것이다**. 자바가 추상화를 위해 제공하는 가장 유용한 도구가 인터페이스이다.

![image](https://github.com/Eui9179/spring3-study/assets/83222282/a5f5769b-cf0f-4d46-a6a1-6a65c8115bb3)

이제 UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.

```java
public interface ConnectionMaker {
    public Connection makeConnection();
}
```

```java
public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection {
            // D 사의 독자적인 방법으로 Connection을 생성하느 ㄴ코드
    }
}
```

이제 코드를 수정해보자.

```java
public Class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao() {
            connectionMaker = new DConnectionMaker(); // -> 여전히 구체적인 클래스에 의존
    }
    // add(), get() ...
}
```

이제는 D사가 DB 접속용 클래스를 다시 만든다고 해도 UserDao의 코드를 뜯어 고칠 일은 없을 것 같다. 그런데 UserDao 코드에는 여전히 `DConnectionMaker()`라는 클래스에 의존한다.

결국 DConnectionMaker를 변경하게 되면 UserDao를 변경해야한다.

![image](https://github.com/Eui9179/spring3-study/assets/83222282/bbda1c4d-f7a8-412e-a378-0780a5bb36cc)


### 1.3.3 관계설정 책임의 분리

UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 대한 관심이다. 이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

해결법은 UserDao의 클라이언트 객체에서 UserDao가 어떤 ConnectionMaker의 구현 클래스를 사용할지를 결정하도록 만드는 것이다.

오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.

```java
public Class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
            this.connectionMaker = connectionMaker;
    }
    // add(), get() ...
}
```

이제 ConnectionMaker는 외부에서 주입해주면 된다.

```java
main() {
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao dao = new UserDao(connectionMaker);
}
```

main은 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존 관계를 설정하는 책임을 담당한다.

드디어 UserDao에 있으면 안 되는 다른 관심 사항, 책임을 클라이언트로 떠넘기는 작업이 끝났다.

클라이언트인 main 덕분에 UserDao 변경 없이도 자유롭게 N 사와 D 사는 자신들을 위한 DB 접속 클래스를 만들어서 UserDao가 사용할 수 있게 되었다.

### 1.3.4 원칙과 패턴

**개방 폐쇄 원칙**

개방 폐쇄 원칙을 이용하면 지금까지 해온 리팩토링 작업의 특징과 장점을 효과적으로 설명할 수 있다.

이 원칙은 ‘클래스나 모듈은 확장에 열려 있어야 하고 변경에는 닫혀 있어야 한다’ 라고 정의할 수 있다. UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다. UserDao에 전혀 영향을 주지 않고도 얼마든지 기능을 확장할 수 있다.

**높은 응집도 낮은 결합도**

모듈의 변화가 생길 때 여러 부분을 파악하고 테스트해야 한다면 부담이 생긴다.

처음 UserDao는 DB 커넥션이 밀접하게 결합되어 있어서 DB 커넥션의 변경은 UserDao의 변경을 의미했다.

반면에 ConnectionMaker 인터페이스를 이용해 DB 커넥션 기능을 독립시킨 경우라면 DB 커넥션의 변경은 DB 커넥션의 변경만 의미한다.

같은 관심끼리 뭉치고 다른 관심은 분리되는 것이 높은 응집도 낮은 결합도를 의미한다.



# 제어의 역전 IoC

## 1.4.1 오브젝트 팩토리

지금까지 main() 에서 객체를 생성하고 의존성을 주입하는 역할을 하였다.
이제부터는 이 역할을 할 팩토리를 생성할 것이다.

### 팩토리

이 클래스의 역할은 객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 것이다. (디자인 패턴에서 말하는 팩토리 패턴과는 다른다)
단지 오브젝트를 생성하는 쪽과 오브젝트를 사용하는 쪽의 분리를 위해 만드는 것이다.

팩토리 역할을 맡은 클래스를 DaoFactory라고 하자.

```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(connectionMaker());
	}

	public AccountDao accountDao() {
		return new AccountDao(connectionMaker());
	}
		
	public ConnectionMaker connectionMaker() {
		return new DConnectionMaker();
	}
}
```

### 설계도로서의 팩토리

![image](https://github.com/Eui9179/spring3-study/assets/83222282/d8ca05b0-7083-4f7c-b42d-4e5ce33d3d7d)


UserDao와 ConnectionMaker는 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고 DaoFactory는 오브젝트를 구성하고 관계를 정의하는 책임을 맡고 있다.

## 1.4.3 제어권의 이전을 통한 제어관계 역전

제어의 역전은 간단히 말해 프로그램의 제어 흐름 구조가 뒤바뀌는 것을 의미한다.

일반적인 프로그램의 흐름은 main() 메소드 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 생성하고 호출하는 방식이다.
UserDao 클래스는 오브젝트를 직접 생성하고, 만들어진 오브젝트의 메소드를 사용한다. 오브젝트를 필요한 시점에서 생성해두고 각 메소드에서 이를 사용한다.
모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다.

**제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고 생성하지 않는다. 또한 객체 스스로는 어떻게 만들어지고 어디서 사용되는지 알 수 없다.**

모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

이러한 제어권을 가지고 애플리케이션 코드를 짜놓은 틀 안에서 실행하는 것이 프레임워크이다.

앞서 만들었던 UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다. 원래 ConnectionMaker의 구현 클래스를 결정하는 것이 UserDao에 있었지만 DaoFactory에게 위임한 것이다.
